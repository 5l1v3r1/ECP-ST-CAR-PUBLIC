\subsubsection{\stid{6.02} LLNL ATDM: Caliper}

\paragraph{Overview}

Caliper is a program instrumentation and performance measurement
framework. It is designed as a performance analysis toolbox in a library,
allowing one to bake performance analysis capabilities directly into
applications and activate them at runtime. Caliper can be used for
lightweight always-on profiling or advanced performance engineering use
cases, such as tracing, monitoring, and auto-tuning. It is primarily
aimed at HPC applications, but works for any C/C++/Fortran program on
Unix/Linux.

\paragraph{Key Challenges}

Caliper addresses the challenges of providing {\it meaningful}
measurements for large applications.  Often, measurements of FLOPs,
timings, data movement, and other quantities are not assocciated with key
application constructs that give them meaning.  For example, we may know
the number of floating point instructions over an entire applciation run,
but if we do not know the number of mesh elements or the particular
physics phase associated with the measurement, we may be unable to
determine whether the FLOPS achieved are good or bad.  Caliper separates
these concerns: application developers can instrument the phases other
context in their code, and performance analysts and users may turn on
performance measurements that are then associated with the context.
Caliper associates meaning with HPC performance measurements.

\paragraph{Solution Strategy}

Caliper is implemented as a C++ library and is linked with applications.
Application teams integrate it with their code by adding Caliper
annotations at the application level.  Contrast this with binary analysis
and DWARF line mappings used by most performance tools, which are
obtained automatiaclly but increase tool complexity and are typically
{\it not} linked with the application for regular runs.

Applications, their libraries, physics modules, and even runtime systems
can be instrumented with Caliper and measured at the same time.  All of
these layers of the application stack provide additional context to
Caliper measuements and enable deeper analysis of the relationships
between different parts of the code.

\paragraph{Recent Progress}

\begin{itemize}
\item Caliper has been integrated with ASC codes such as ARES and ARDRA.
\item Caliper has been integrated with LLNL's SPOT performance tracking tool,
      which provides code teams with nightly performance data.
\end{itemize}

\paragraph{Next Steps}

LLNL's ProTools continues to add Caliper into more and more ASC/ATDM
codes so that all codes report their performance to a central dashboard.
A large number of ATDM codes and libraries have asked for Caliper
support, and the team's goal in the coming year is to satisfy all of
these demands.  The end result of this is to have application users
running codes, producing behind-the-scenes performance data, and then
application developers browsing and analyzing the performance data with
analytic frameworks and novel visualizations.
